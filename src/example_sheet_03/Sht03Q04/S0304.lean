import analysis.real

lemma mul_pos_iff_div_pos {x y : ℝ} (Hy : y ≠ 0) : 0 < x * y ↔ 0 < x / y :=
begin
  have H : 0 < y * y := mul_self_pos Hy,
  split,
    intro H1,
    have H2 : (x * y) / (y * y) = x / y,
      rw div_eq_div_iff (ne_of_gt H) Hy,
      rw mul_assoc,
    rw ←H2,
    apply div_pos H1 H,
  intro H1,
  have H2 : (x / y) * (y * y) = x * y,
    rw div_mul_eq_mul_div_comm,
    rw mul_div_cancel _ Hy,
  rw ←H2,
  exact mul_pos H1 H,
end

-- this seems like a huge effort. Maybe I'm missing something.
theorem Q4 : { x : ℝ | x ≠ 0 ∧ 3 * x + 1 / x < 4 } = 
  {x : ℝ | x < 0 ∨ ((1 : ℝ) / 3 < x ∧ x < 1)} :=
begin
  ext x,
  show x ≠ 0 ∧ 3 * x + 1 / x < 4 ↔ x < 0 ∨ 1 / 3 < x ∧ x < 1,
  cases classical.em (x = 0) with H0 Hn0,
  { -- junk case x = 0
    rw H0,
    norm_num,
  },
  rw (show x ≠ 0 ↔ true, by simp [Hn0]),
  rw true_and,
  show (3 : ℝ) * x + 1 / x < 4 ↔ x < 0 ∨ 1 / 3 < x ∧ x < 1,
  have this : (3 : ℝ) * x + 1 / x < 4 ↔ 0 < 4 - (3 * x + 1 / x)
    := (@sub_pos ℝ (by apply_instance) (4 : ℝ) ((3 : ℝ) * x + 1 / x)).symm,
  rw this,
  rw ←sub_sub,
  rw ←mul_one (4 - 3 * x),
  -- annoying rewrite
  have H : 0 < (4 - 3 * x) * 1 - 1 / x ↔ 0 < (4 - 3 * x) * (x / x) - 1 / x,
    rw div_self Hn0,
  rw H,  
  rw ←mul_div_assoc,
  rw ←sub_div,
  rw ←mul_pos_iff_div_pos Hn0,
  replace H : x * x > 0 := mul_self_pos Hn0,
  rw (show ((4 - 3 * x) * x - 1) * x = (1 - x) * x * (3 * x - 1), by ring),
  -- goal now 
  -- ⊢ 0 < (1 - x) * x * (3 * x - 1) ↔ x < 0 ∨ 1 / 3 < x ∧ x < 1
  cases lt_or_ge x 0 with h h1,
  -- x < 0
    rw (show x < 0 ↔ true, by simp [h]),
    rw true_or,
    rw iff_true,
    apply mul_pos_of_neg_of_neg,
      refine mul_neg_of_pos_of_neg _ h,
      apply sub_pos_of_lt,
      apply lt_trans h zero_lt_one,
    apply sub_neg_of_lt,
    refine lt_trans _ zero_lt_one,
    apply mul_neg_of_pos_of_neg _ h,
    norm_num,
  rw (show x < 0 ↔ false, by rw iff_false; exact not_lt_of_ge h1),
  rw false_or,
  cases le_or_gt x ((1 : ℝ) / 3) with h2 h2,
    rw (show (1 : ℝ) / 3 < x ↔ false, by rw iff_false; exact not_lt_of_ge h2),
    rw false_and,
    rw iff_false,
    apply not_lt_of_ge,
    refine mul_nonpos_of_nonneg_of_nonpos _ _,
      refine mul_nonneg _ h1,
      show 0 ≤ 1 - x,
      rw sub_nonneg,
      exact le_trans h2 (by norm_num),
    rw sub_nonpos,
    rw mul_comm,
    apply mul_le_of_le_div (by norm_num) h2,
  cases lt_or_ge x 1,
    rw (iff_true ((1 : ℝ) / 3 < x)).2 h2,
    rw (iff_true (x < 1)).2 h,
    rw true_and,
    rw iff_true,
    refine mul_pos _ _,
      refine mul_pos _ _,
        show 0 < (1 - x),
        rwa sub_pos,
      refine lt_trans (by norm_num) h2,
    show 0 < 3 * x - 1,
    rw sub_pos,
    rwa ←div_lt_iff',
    norm_num,
  rw (show x < 1 ↔ false, by rw iff_false; exact not_lt_of_ge h),
  rw and_false,
  rw iff_false,
  apply not_lt_of_ge,
  refine mul_nonpos_of_nonpos_of_nonneg _ _,
    refine mul_nonpos_of_nonpos_of_nonneg _ h1,
    simp [h], exact h,
  show 0 ≤ 3 * x - 1,
  rw sub_nonneg,
  rw mul_comm,
  apply le_mul_of_div_le,
    norm_num,
  apply le_trans _ h,
  norm_num,
end